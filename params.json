{"name":"FunnyQT","tagline":"Functional Model Queries and Transformations","body":"<link rel=\"icon\" href=\"https://raw.githubusercontent.com/jgralab/funnyqt/master/logos/icon32.png\">\r\n\r\n[![License GPL 3][badge-license]](http://www.gnu.org/licenses/gpl-3.0.txt)\r\n[![Build Status](https://secure.travis-ci.org/jgralab/funnyqt.png)](http://travis-ci.org/jgralab/funnyqt)\r\n[![Clojars Project](http://clojars.org/funnyqt/latest-version.svg)](http://clojars.org/funnyqt)\r\n\r\n<object data=\"http://jgralab.github.io/funnyqt/images/funnyqt.svg\" type=\"image/svg+xml\" width=\"600\">\r\n  <img src=\"http://jgralab.github.io/funnyqt/images/funnyqt.png\" width=\"600\">\r\n</object>\r\n\r\n# Welcome!\r\n\r\nFunnyQT is a model querying and transformation library.  It currently supports\r\nthe [Java Graph Laboratory](http://jgralab.github.io/jgralab) and the\r\n[Eclipse Modeling Framework](http://www.eclipse.org/modeling/emf/).\r\n\r\n# Table of Contents\r\n\r\n1. [Documentation](#documentation)\r\n  - [FunnyQT Overview](#funnyqt-overview)\r\n  - [API Documentation](#api-documentation)\r\n  - [Publications](#publications)\r\n2. [Getting FunnyQT](#getting-funnyqt)\r\n  - [Getting a Release](#getting-a-release)\r\n  - [Getting the Git Version](#getting-the-git-version)\r\n3. [Getting Support](#getting-support)\r\n  - [Contact the Author](#contact-the-author)\r\n  - [IRC Channel](#irc-channel)\r\n  - [Found a Bug?](#found-a-bug)\r\n\r\n# Documentation\r\n\r\nCheck out the [overview description](#funnyqt-overview), the\r\n[generated API documentation](#api-documentation), and the\r\n[papers about FunnyQT](#publications).\r\n\r\n## FunnyQT Overview\r\n\r\nThe FunnyQT API is structured into the following sub-APIs realized in several\r\nnamespaces.\r\n\r\nThe foundation is an extensive **core API** providing typical _model management\r\nservices_ such as creating, loading, and storing models, accessing, creating,\r\nand deleting model elements, and accessing model element properties.  The core\r\nAPI is subdivided into two framework-specific namespaces (EMF or JGraLab) and\r\none namespace providing functions working with either kind of model\r\nrepresentation.\r\n\r\n  - _funnyqt.emf_: The EMF-specific core API\r\n  - _funnyqt.tg_: The TGraph-specific core API (JGraLab)\r\n  - _funnyqt.generic_: Core functions working with both kinds of models/model\r\n    elements, and protocols extended on EMF and JGraLab interfaces\r\n\r\nThe **functional querying API** builds upon the core API and provides features\r\nsuch as navigation inside models in terms of role names, quantified\r\nexpressions, and _regular path expressions_.  Like the core API, some\r\nframework-specific parts are outsourced into their own two querying namespaces.\r\n\r\n  - _funnyqt.query_: Generic querying services such as quantified expressions,\r\n    sorting functions, and generic regular path operators.\r\n  - _funnyqt.query.emf_: EMF-specific regular path operators\r\n  - _funnyqt.query.tg_: TGraph-specific regular path operators\r\n\r\nFunnyQT's **polymorphic function API** provides constructs for defining\r\nfunctions dispatching on metamodel type.\r\n\r\n  - _funnyqt.polyfns_: Polymorphic function API\r\n\r\nThe **pattern-matching API** provides constructs for defining patterns using\r\nnode and edge symbols.  When a pattern is called on some model, it returns a\r\nlazy sequence of all matches in the model.\r\n\r\n  - _funnyqt.pmatch_: Pattern-matching in models\r\n\r\nBased on the pattern-matching API, there's a **in-place transformation API**\r\nthat allows to define rules consisting of a pattern and a sequence of actions.\r\nWhen a rule is invoked, it searches for a match in the model and applies its\r\nactions to it.  Typical control structures such as as-long-as-possible\r\napplication of a rule are provided as higher-order functions.\r\n\r\n  - _funnyqt.in-place_: In-place transformations and state-space exploration\r\n\r\nFunnyQT provides two kinds of *model transformation APIs*.  The **extensional\r\nmodel transformation API** builds upon GReTL's concepts of extensional\r\nsemantics and is an operational transformation API, whereas the **model2model\r\nAPI** realizes a rule-based approach to model transformations.\r\n\r\n  - _funnyqt.extensional_: Generic parts of the extensional model\r\n    transformation API\r\n  - _funnyqt.extensional.emf_: The EMF-specific parts of the extensional model\r\n    transformation API\r\n  - _funnyqt.extensional.tg_: The TGraph-specific parts of the extensional\r\n    model transformation API\r\n  - _funnyqt.model2model_: The rule-based model transformation API\r\n\r\nThe **relational querying API** allows for Prolog-like logical querying of\r\nmodels using the [core.logic](http://github.com/clojure/core.logic) library.\r\n\r\n  - _funnyqt.relational_: Generic relations\r\n  - _funnyqt.relational.emf_: EMF-specific relations\r\n  - _funnyqt.relational.tg_: TGraph-specific relations\r\n\r\nBased on the relational querying API, there's a **bidirectional transformation\r\nAPI**.\r\n\r\n  - _funnyqt.bidi_: Bidirectional model transformations\r\n\r\nSuch a transformation specifies correspondences between a left and a right\r\nmodel in terms of relations between elements in those models.  Such a\r\ntransformation can be used to generate a new right model from a given left\r\nmodel and vice versa.  Additionally, it can be used to synchronize between two\r\nexisting models in either direction.\r\n\r\nFor TGraphs, there is a **co-evolution transformation API**.\r\n\r\n- _funnyqt.coevo.tg_: Co-evolution transformations\r\n\r\nCo-evolution transformations allow to evolve a schema and a conforming graph\r\nsimultaneously at runtime.\r\n\r\nFinally, there are some **utility and helper APIs**.\r\n\r\n  - _funnyqt.utils_: Generic utility functions\r\n  - _funnyqt.visualization_: Visualizing models using\r\n    [GraphViz](http://www.graphviz.org/)\r\n  - _funnyqt.xmltg_: Converting arbitrary XML documents to DOM-like TGraphs and\r\n    back again\r\n\r\n\r\n## API Documentation\r\n\r\nThe FunnyQT API docs generated for the current release are\r\n[here](http://userpages.uni-koblenz.de/~horn/funnyqt-docs/).\r\n\r\n## Publications\r\n\r\n- _Model Querying with FunnyQT_, Tassilo Horn,\r\n  [ICMT 2013](http://www.model-transformation.org/ICMT2013/),\r\n  http://dx.doi.org/10.1007/978-3-642-38883-5_7\r\n\r\n- _Solving the TTC 2013 Flowgraphs Case with FunnyQT_, Tassilo Horn,\r\n  [TTC 2013](http://planet-sl.org/ttc2013),\r\n  http://dx.doi.org/10.4204/EPTCS.135.7\r\n\r\n- _Solving the Class Diagram Restructuring Transformation Case with FunnyQT_,\r\n  Tassilo Horn, [TTC 2013](http://planet-sl.org/ttc2013),\r\n  http://dx.doi.org/10.4204/EPTCS.135.9\r\n\r\n- _Solving the Petri-Nets to Statecharts Transformation Case with FunnyQT_,\r\n  Tassilo Horn, [TTC 2013](http://planet-sl.org/ttc2013),\r\n  http://dx.doi.org/10.4204/EPTCS.135.11\r\n\r\n- _Bidirectional Model Transformations With FunnyQT_, Tassilo Horn, rejected at\r\n  both BX'14 and ICMT'14, but I consider it to be my best paper so far anyway\r\n  (and the only one about FunnyQT bidirectional transformations),\r\n  http://userpages.uni-koblenz.de/~horn/mypapers/funnyqt-bidi2014.pdf\r\n\r\n- _Solving the TTC Movie Database Case with FunnyQT_, Tassilo Horn,\r\n  [TTC 2014](http://www.transformation-tool-contest.eu/solutions_movie.html)\r\n\r\n- _Solving the TTC FIXML Case with FunnyQT_, Tassilo Horn,\r\n  [TTC 2014](http://www.transformation-tool-contest.eu/solutions_fixml.html)\r\n\r\n# Getting FunnyQT\r\n\r\nThere are two ways of getting FunnyQT.  When you want to use it for writing\r\nyour own queries and transformations, you should\r\n[get the latest release](#getting-a-release) available with Leiningen.  If you\r\nwant to have the bleeding edge version from git, e.g., to validate that some\r\nbug has been fixed, see how to [get the git version](#getting-the-git-version).\r\n\r\n## Getting a Release\r\n\r\nIf you don't intend to hack on FunnyQT itself but you just want to use it for\r\nwriting queries and transformations, the easiest possibility is to use the\r\nlatest FunnyQT release that's available via the\r\n[Clojars Maven repository](http://clojars.org/funnyqt).\r\n\r\nTo create query/transformation project using FunnyQT, simply perform the\r\nfollowing steps:\r\n\r\n1. Install the `lein` shell (or bat) script as explained on the\r\n   [Leiningen](http://leiningen.org) homepage.\r\n\r\n2. Create a new project.\r\n\r\n    ```\r\n    $ lein new my-funnyqt-transform\r\n    Generating a project called my-funnyqt-transform based on the 'default' template.\r\n    To see other templates (app, lein plugin, etc), try `lein help new`.\r\n    ```\r\n\r\n3. Declare that your project depends on FunnyQT.  Replace 0.42.0 below with\r\n   whatever is the the [current FunnyQT release](http://clojars.org/funnyqt).\r\n\r\n    ```\r\n    $ cd my-funnyqt-transform\r\n    $ edit project.clj\r\n    # add funnyqt in the project :dependencies\r\n    (defproject my-funnyqt-transform \"0.1.0-SNAPSHOT\"\r\n      :description \"FIXME: write description\"\r\n      :url \"http://example.com/FIXME\"\r\n      :license {:name \"Eclipse Public License\"\r\n                :url \"http://www.eclipse.org/legal/epl-v10.html\"}\r\n      :dependencies [ [funnyqt \"0.42.0\"] ])\r\n    ```\r\n\r\n4. Now start a REPL and start hacking.  Leiningen will take care of fetching\r\n   all dependencies such as Clojure and FunnyQT.\r\n\r\n    ```\r\n    nREPL server started on port 44783 on host 127.0.0.1 - nrepl://127.0.0.1:44783\r\n    REPL-y 0.3.5, nREPL 0.2.6\r\n    Clojure 1.7.0-alpha5\r\n    OpenJDK 64-Bit Server VM 1.8.0_40-b20\r\n       Docs: (doc function-name-here)\r\n             (find-doc \"part-of-name-here\")\r\n     Source: (source function-name-here)\r\n    Javadoc: (javadoc java-object-or-class-here)\r\n       Exit: Control+D or (exit) or (quit)\r\n    Results: Stored in vars *1, *2, *3, an exception in *e\r\n    user=> ;; Here you go!\r\n    ```\r\n\r\n## Getting the Git Version\r\n\r\nFunnyQT uses [Leiningen](http://leiningen.org) for retrieving all its\r\ndependencies from various Maven repositories, building, publishing, and test\r\nautomation.\r\n\r\nGetting started is really simple:\r\n\r\n1. Install the `lein` shell (or bat) script as explained on the\r\n   [Leiningen](http://leiningen.org) homepage.\r\n\r\n2. Clone the FunnyQT git repository:\r\n\r\n    ```\r\n    $ git clone https://github.com/jgralab/funnyqt.git\r\n    ```\r\n\r\n3. Just to be sure everything's fine, you might want to execute the test cases.\r\n\r\n    ```\r\n    $ cd funnyqt\r\n    $ lein test\r\n    ```\r\n\r\n4. You are ready to go.  Start a REPL and start hacking.\r\n\r\n    ```\r\n    $ lein repl\r\n    REPL started; server listening on localhost port 22815\r\n    user=> (use 'funnyqt.tg)\r\n    nil\r\n    user=> (def g (load-graph \"test/input/greqltestgraph.tg\"))\r\n    #<Graph c06de1c7-f4ec0906-21cfbc86-28c31aa1 (1175): RouteMap>>\r\n    user=> (vseq g 'localities.City)\r\n    (#<v6: localities.City> #<v7: localities.City> #<v8: localities.City>)\r\n    ```\r\n\r\n# Getting Support\r\n\r\n## Contact the Author\r\n\r\nFunnyQT is developed by Tassilo Horn ([tsdh](http://github.com/tsdh)).  If you\r\nwant, you can get in touch with me via [email](mailto:horn@uni-koblenz.de),\r\n[IRC](#irc-channel), or [G+](http://plus.google.com/u/0/+TassiloHorn).\r\n\r\n## IRC Channel\r\n\r\nJoin us on the official [JGraLab IRC Channel](irc://irc.freenode.net/#jgralab)\r\n(channel `#jgralab` on `irc.freenode.net`).  If you don't have or don't want to\r\ninstall an IRC client, you can also\r\n[chat directly in your browser](http://webchat.freenode.net/?channels=jgralab).\r\n\r\n## Found a Bug?\r\n\r\nAlthough that should be quite impossible and is surely an error on your side\r\n`>:)`, if you found a bug or miss an important feature, file a bug report in\r\nthe [FunnyQT issue tracker](http://github.com/jgralab/funnyqt/issues).\r\n\r\n# License\r\n\r\nCopyright (C) 2011-2015 Tassilo Horn <horn@uni-koblenz.de> & The JGraLab Team <ist@uni-koblenz.de>\r\n\r\nDistributed under the\r\n[General Public License, Version 3](http://www.gnu.org/copyleft/gpl.html) with\r\nthe following additional grant:\r\n\r\n    Additional permission under GNU GPL version 3 section 7\r\n\r\n    If you modify this Program, or any covered work, by linking or combining it\r\n    with Eclipse (or a modified version of that program or an Eclipse plugin),\r\n    containing parts covered by the terms of the Eclipse Public License (EPL),\r\n    the licensors of this Program grant you additional permission to convey the\r\n    resulting work.  Corresponding Source for a non-source form of such a\r\n    combination shall include the source code for the parts of JGraLab used as\r\n    well as that of the covered work.\r\n\r\n[![License GPL 3][badge-license]](http://www.gnu.org/licenses/gpl-3.0.txt)\r\n[badge-license]: https://img.shields.io/badge/license-GPL_3-green.svg\r\n\r\n<!-- Local Variables:        -->\r\n<!-- mode: markdown          -->\r\n<!-- indent-tabs-mode: nil   -->\r\n<!-- End:                    -->\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}