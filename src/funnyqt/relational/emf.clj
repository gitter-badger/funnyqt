(ns funnyqt.relational.emf
  (:require [clojure.core.logic           :as ccl]
            [clojure.core.logic.protocols :as cclp]
            [funnyqt.generic              :as g]
            [funnyqt.emf                  :as emf]
            [funnyqt.query                :as q]
            [funnyqt.relational.tmp-elem  :as tmp]
            [funnyqt.relational.util      :as ru]
            [funnyqt.relational.internal  :as ri]
            [funnyqt.utils                :as u])
  (:import
   (org.eclipse.emf.ecore EStructuralFeature EAttribute EReference EObject
                          EClass EPackage)))

(defn tmp-eobjecto
  ([m eo]
   (fn [a]
     (let [geo (cclp/walk a eo)]
       (cond
         (not (or (ru/fresh? geo) (tmp/tmp-or-wrapper-element? geo)))
         (u/errorf "tmp-eobjecto/2: eo must be fresh or a ground Wrapper/TmpElement but was %s."
                   geo)

         (ru/ground? geo)
         (if (tmp/set-kind geo :element)
           (ccl/succeed a)
           (ccl/fail a))

         :else (ccl/to-stream
                (->> (map #(ccl/unify a eo %)
                          (concat
                           (map (partial tmp/make-wrapper m eo)
                                (emf/eallcontents m))
                           [(tmp/make-tmp-element m :element)]))
                     (remove not)))))))
  ([m eo t]
   (fn [a]
     (let [geo (cclp/walk a eo)
           gt  (cclp/walk a t)]
       (cond
         (not (ru/ground? gt))
         (u/errorf "tmp-eobjecto/3: type must be ground.")

         (not (or (ru/fresh? geo) (tmp/tmp-or-wrapper-element? geo)))
         (u/errorf "tmp-eobjecto/3: eo must be fresh or a ground Wrapper/TmpElement but was %s."
                   geo)

         (ru/ground? geo) ;; TODO: we probably need something like tg/kind-aec-tup-from-spec, too
         (if (and (tmp/set-kind geo :element)
                  (tmp/set-type geo gt))
           (ccl/succeed a)
           (ccl/fail a))

         :else (ccl/to-stream
                (->> (map #(ccl/unify a eo %)
                          (concat
                           (map (partial tmp/make-wrapper m eo)
                                (emf/eallcontents m gt))
                           [(tmp/make-tmp-element m :element gt)]))
                     (remove not))))))))

(defn eobjecto
  "A relation where EObject `e` has the type `t`, an EClass name in Resouce or
  ResourceSet `m`.  In fact, `t` may be any type specification (see
  `funnyqt.generic/type-matcher`)."
  ([m eo]
     (if tmp/*make-tmp-elements*
       (tmp-eobjecto m eo)
       (fn [a]
         (let [geo (cclp/walk a eo)]
           (if (ru/ground? geo)
             (if (emf/eobject? geo) (ccl/succeed a) (ccl/fail a))
             (ccl/to-stream
              (->> (map #(ccl/unify a eo %)
                        (emf/eallcontents m))
                   (remove not))))))))
  ([m eo t]
     (if tmp/*make-tmp-elements*
       (tmp-eobjecto m eo t)
       (fn [a]
         (let [geo (cclp/walk a eo)
               gt (cclp/walk a t)]
           (cond
            (or (and (ru/ground? geo) (not (emf/eobject? geo)))
                (and (ru/ground? gt) (not (or (symbol? gt) (coll? gt)))))
            (ccl/fail a)

            (and (ru/ground? geo) (ru/ground? gt))
            (if (g/has-type? geo gt)
              (ccl/succeed a)
              (ccl/fail a))

            (ru/ground? geo)
            (ccl/unify a t (g/qname geo))

            (ru/ground? gt)
            (ccl/to-stream
             (->> (map #(ccl/unify a eo %) (emf/eallcontents m t))
                  (remove not)))

            :else (ccl/to-stream
                   (->> (for [elem (emf/eallcontents m t)]
                          (ccl/unify a [eo t] [elem (g/qname elem)]))
                        (remove not)))))))))

(defn ^:private attribute-list [eo]
  (seq (.getEAllAttributes (.eClass ^EObject eo))))

(defn valueo
  "A relation where EObject `eo` has value `val` for its `at` attribute in
  EMF Resource or ResourceSet `m`.

  The parameter `may-override` specifies that the attribute value may be
  overridden when transforming into the direction of `m` in a bidirectional
  transformation.  (You normally shouldn't use that parameter directly, but use
  the API generated by `generate-ecore-model-relations`.)"
  ([m eo at val]
     (valueo m eo at val false))
  ([m eo at val may-override]
     (if tmp/*make-tmp-elements*
       (ri/tmp-valueo m eo at val may-override)
       (fn [a]
         (let [geo  (cclp/walk a eo)
               gat  (cclp/walk a at)
               gval (cclp/walk a val)]
           (cond
            (or (and (ru/ground? geo) (not (emf/eobject? geo)))
                (and (ru/ground? gat) (not (keyword? gat)))
                (and (ru/ground? geo) (ru/ground? gat)
                     (not (when-let [sf (.getEStructuralFeature
                                         (.eClass ^EObject geo) ^String (name gat))]
                            (emf/eattribute? sf)))))
            (ccl/fail a)

            (and (ru/ground? geo) (ru/ground? gat))
            (ccl/unify a val (emf/eget geo gat))

            (ru/ground? geo)
            (ccl/to-stream
             (->> (for [^EAttribute attr (attribute-list geo)
                        :let [an (keyword (.getName attr))]]
                    (ccl/unify a [at val] [an (emf/eget geo an)]))
                  (remove not)))

            :else (ccl/to-stream
                   (->> (for [^EObject elem (emf/eallcontents m)
                              ^EAttribute attr (attribute-list elem)
                              :let [an (keyword (.getName attr))]]
                          (ccl/unify a [eo at val] [elem an (emf/eget elem an)]))
                        (remove not)))))))))

(defn ^:private reference-list [eo]
  (seq (.getEAllReferences (.eClass ^EObject eo))))

(defn refo
  "A relation where `eo` references `reo` with its `ref` reference in the EMF
  Resource or ResourceSet `m`.

  The parameter `may-override` specifies that in case of a single-valued
  reference, the referenced object may be overridden when transforming into the
  direction of `m` in a bidirectional transformation.  (You normally shouldn't
  use that parameter directly, but use the API generated by
  `generate-ecore-model-relations`.)"
  ([m eo ref reo]
     (refo m eo ref reo false))
  ([m eo ref reo may-override]
     (if tmp/*make-tmp-elements*
       (ri/tmp-adjo m eo ref reo may-override)
       (fn [a]
         (let [geo  (cclp/walk a eo)
               gref (cclp/walk a ref)
               greo (cclp/walk a reo)]
           (cond
            (or (and (ru/ground? geo) (not (emf/eobject? geo)))
                (and (ru/ground? gref) (not (keyword? gref)))
                (and (ru/ground? greo) (not (emf/eobject? greo)))
                (and (ru/ground? geo) (ru/ground? gref)
                     (not (when-let [sf (.getEStructuralFeature
                                         (.eClass ^EObject geo) ^String (name gref))]
                            (emf/ereference? sf)))))
            (ccl/fail a)

            (and (ru/ground? geo) (ru/ground? gref))
            (ccl/to-stream
             (->> (for [refed (funnyqt.generic/adjs* geo gref)]
                    (ccl/unify a [reo] [refed]))
                  (remove not)))

            (ru/ground? geo)
            (ccl/to-stream
             (->> (for [^EReference reference (reference-list geo)
                        :let [rn (keyword (.getName reference))]
                        refed (funnyqt.generic/adjs* geo rn)]
                    (ccl/unify a [ref reo] [rn refed]))
                  (remove not)))

            :else (ccl/to-stream
                   (->> (for [^EObject elem (emf/eallcontents m)
                              ^EReference reference (reference-list elem)
                              :let [rn (keyword (.getName reference))]
                              refed (funnyqt.generic/adjs* elem rn)]
                          (ccl/unify a [eo ref reo] [elem rn refed]))
                        (remove not)))))))))

;;# Metamodel specific relations

(defn ^:private class->rel-symbols
  "Returns a relation symbol for the eclass `c`."
  [^EClass c prefix]
  (let [fqn (g/uname c)]
    (mapv (fn [s]
            (with-meta (symbol s)
              {:relation-name
               (symbol (str prefix (clojure.string/replace
                                    s #"([!])?.*[.]" #(or (nth % 1) ""))))}))
          [fqn (str fqn "!") (str "!" fqn) (str "!" fqn "!")])))

(defn ^:private create-eclass-relations
  "Creates relations for the given eclass."
  [ecls prefix]
  `(do
     ~@(for [na (class->rel-symbols ecls prefix)]
         `(defn ~(:relation-name (meta na))
            ~(format "A relation where `eo` is an %s EObject." na)
            [~'m ~'eo]
            (eobjecto ~'m ~'eo '~na)))))

(defn ^:private create-ereference-relations
  "Creates relations for the given EReference."
  [eref ecls prefix]
  (let [ts (mapv #(g/qname %) ecls)]
    `(do
       (defn ~(symbol (str prefix "->" (clojure.string/replace (name eref) "_" "-")))
         ~(format "A relation where `eo` includes `reo` in its %s reference." eref)
         [~'m ~'eo ~'reo]
         (ccl/all
          (eobjecto ~'m ~'eo '~ts)
          (refo ~'m ~'eo ~eref ~'reo false)))
       ;; If that ref is a single-valued ref (or occurs as such in at least one
       ;; EClass in ecls), generate a override relation, too.
       ~(when (some #(not (g/mm-multi-valued-property? % eref)) ecls)
          `(defn ~(symbol (str prefix "->" (clojure.string/replace (name eref) "_" "-") "*"))
             ~(format "A relation where `eo` includes `reo` in its %s reference.
  When used in a bidirectional transformation executed in the direction of `m`
  the object in that single-valued reference may be overridden." eref)
             [~'m ~'eo ~'reo]
             (ccl/all
              (eobjecto ~'m ~'eo '~ts)
              (refo ~'m ~'eo ~eref ~'reo true)))))))

(defn ^:private create-eattribute-relations
  "Creates relations for the given EAttribute."
  [attr ecls prefix]
  ;; attr is an attr name symbol, ecls the set of classes having
  ;; such an attr
  (let [ts (mapv #(g/qname %) ecls)]
    `(do
       (defn ~(symbol (str prefix (clojure.string/replace (name attr) "_" "-")))
         ~(format "A relation where `eo` has value `val` for its %s attribute." attr)
         [~'m ~'eo ~'val]
         (ccl/all
          (eobjecto ~'m ~'eo '~ts)
          (valueo ~'m ~'eo ~attr ~'val false)))
       (defn ~(symbol (str prefix (clojure.string/replace (name attr) "_" "-") "*"))
         ~(format "A relation where `eo` has value `val` for its %s attribute.
  When used in a bidirectional transformation executed in the direction of `g`
  the attribute value may be overridden." attr)
         [~'m ~'eo ~'val]
         (ccl/all
          (eobjecto ~'m ~'eo '~ts)
          (valueo ~'m ~'eo ~attr ~'val true))))))


;;# Main

(defmacro generate-ecore-model-relations
  "Generates metamodel-specific relations in the namespace denoted by `nssym`.
  `ecore-file` is the ecore file containing the metamodel.

  If `nssym` is nil (or not given), generate them in the current namespace, and
  require it as `alias` (if non-nil/given).

  `prefix` is an optional prefix all relations should have.  (Useful if you
  generate in the current namespace.)

  For any EClass Foo, there will be a relation (+Foo model el) that succeeds
  for all EObjects el in the model that have the type Foo.  Similarly, there
  are relations +!Foo, +Foo!, and +!Foo! restricting to exact Foo instances
  and/or negating.

  For any attribute bar, there will be a relation (+bar model el val) where el
  is an element of model that posesses a bar attribute whose value is val.

  For any reference baz, there will be a relation (+baz model el ref) where el
  is an element of model that posesses a baz reference that links to ref.  If
  baz is a multi-valued reference, then ref is contained in that list.

  Property names containing an underscore will result in relations with a
  hyphen instead, e.g., attribute \"is_persistent\" is translated into a
  relation +is-persistent."
  ([ecore-file]
     `(generate-ecore-model-relations ~ecore-file nil nil nil))
  ([ecore-file nssym]
     `(generate-ecore-model-relations ~ecore-file ~nssym nil nil))
  ([ecore-file nssym alias]
     `(generate-ecore-model-relations ~ecore-file ~nssym ~alias nil))
  ([ecore-file nssym alias prefix]
     `(g/metamodel-api-generator ~ecore-file ~nssym ~alias ~prefix
                                 create-eclass-relations
                                 nil
                                 create-eattribute-relations
                                 create-ereference-relations)))
